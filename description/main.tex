\documentclass{llncs}

\pagestyle{headings}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ruled,linesnumbered,vlined]{algorithm2e}
\usepackage{color}
\usepackage{tabularx}
\usepackage{todonotes}
\usepackage{tabto}
\usepackage{url}
\usepackage{csquotes}
\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,chains,matrix,fit,backgrounds,calc}

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\assign}{\ensuremath{\leftarrow }}

\newcommand{\underapp}[1]{\ensuremath{#1^\downarrow}}
\newcommand{\overapp}[1]{\ensuremath{#1^\uparrow}}

\newcommand{\True}{\ensuremath{\top}}
\newcommand{\False}{\ensuremath{\bot}}
\newcommand{\Undef}{\ensuremath{\mathbf{U}}}
\newcommand{\SAT}{\ensuremath{\mathsf{SAT}}}
\newcommand{\UNSAT}{\ensuremath{\mathsf{UNSAT}}}
\newcommand{\UNDEF}{\ensuremath{\mathsf{UNDEF}}}

\newcommand{\Vars}[1]{\mathsf{vars}(#1)}
\newcommand{\Lits}[1]{\mathsf{lits}(#1)}
\newcommand{\Enc}[1]{\mathsf{enc}(#1)}

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\title{System Description of Candy Kingdom --\\ A Sweet Family of SAT Solvers}
\author{Markus Iser, Felix Kutzner}
\institute{
  Karlsruhe Institute of Technology (KIT), Germany\\
  \url{{markus.iser, felix.kutzner}@kit.edu}
}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

The development of our SAT solver \textbf{Candy} started as a branch of the well-known \textbf{Glucose 3} solver.
With Candy, we aim to facilitate the solver's development by refactoring the Glucose source code towards modern C++ and by reducing dependencies within the source code.
This involved replacing most custom lowest-level data structures and algorithms by their C++ standard library equivalents.
We also increased the extensibility of Candy by using static polymorphism and a modular toolbox source code structure.
The quality of Candy is assured by automated testing with different compilers (clang, gcc, Microsoft C/C++) and operating platforms (Linux, macOS, Windows) using continuous integration systems.

\section{Clause Memory Management}
\label{sec:clauses}

In contrast to Glucose, in Candy clauses are now referenced as regular pointers and for fast access and optimized Cache usage we introduced a dedicated memory management. Clauses are optimized for size so we have a very small clause header that only keep size, activity, lbd value and few flags. Our Clause Allocator preallocates clauses in buckets of equivalently sized clauses up to clauses of length 500. Only clauses exceeding that size limit are allocated by regular new/delete methods. Memory for small clauses is regularly revamped such that the clauses are sorted by their activity (in memory) with the highest activity first. Also the watchers are sorted by clause size and activity. 

\section{Improved Incremental Mode}

In contrast to Glucose we made several optimizations (minimization of learnt clauses with binary resolution, clause simplification) work in incremental mode. Also a certificate can be generated in incremental mode if assumpations are used properly. Candy outputs no proof if clauses containing assumptions were used in the final conflict. 

\section{Inprocessing}

We improved the architecture of clause simplification in Glucuse such that Candy can now perform clause data-base simplification during search. We perform clause strengthening with new unit clauses, clause subsumption and self-subsuming resolution. Clauses of the original problem are included as well as the learnt clauses that are persitent in the learnt-clause database (that includes clauses of size 2 and clauses with lbd <= 2). 

\section{Gate Structure Analysis and Applications}

Candy provides modules for gate extraction \cite{Iser:2015:GateRecognition} and random simulation \cite{krohm1996use}.
Detemerminized random simulation is used on gate structure extracted from SAT problems to generate conjectures about literal equivalences and backbone variables.
The Candy solver variant Candy/RSAR uses these conjectures to compute and iteratively refine under-approximations of the SAT problem instance \cite{Kutzer:2016:Thesis}.
The Candy solver variant Candy/RSIL uses branching heuristics based on implicit learning \cite{Kutzer:2016:Thesis,DBLP:journals/jucs/LuWCMH04} to stimulate clause learning by violating extracted conjectures about variable equivalencies where possible, otherwise using the VSIDS branching heuristic.
Candy/RSIL includes the sub-variants Candy/RSILv, with which the probability of implicit learning being used is iteratively decreased during the solver execution, and Candy/RSILi, with which usage budgets are assigned to each conjecture.
Using branching heuristics based on implicit learning has proven to be particularly efficient for solving miter problems with general-purpose SAT solvers \cite{Kutzer:2016:Thesis}.
Candy includes fast miter problem detection heuristics enabling implicit learning to be enabled only for SAT problem instances detected to be miter encodings.
For a general description of miter problems, see e.g. \cite{hwmcc12Bench}.


%\section{Gate Structure Analysis and Random Simulation}
%Candy includes modules that perform gate extraction, miter detection and random simulation. The random simulation module uses extracted gates to generate conjectures about literal equivalences and backbones. The Candy solver variants RSAR, RSIL and RSILmd, make use of the extracted information. RSIL uses its own pick-branch-lit implementation (hooked in as a template parameter) that tries to violate extracted conjectures about variable equivalences in order to stimulate clause learning. The variant RSILmd does that only if miter structure is detected. RSAR uses the conjectures in an abstraction refinement loop by adding them to the problem and relaxing them if necessary. 
    

\bibliographystyle{splncs03}
%\bibliographystyle{abbrv}
\bibliography{abstractionrefinement,blockedsets,general,preprocessing,structurerecognition,applications,encodings,otherstructure,self}

\end{document}
